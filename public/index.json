[{"categories":["stdlib"],"content":" Context Mojo Documentation: Variant Youtube: Overview of Dict, Variant and Optional in MojoðŸ”¥ Mojo Version: 24.2.0 Demo: Summing Integers and String Representations This demo illustrates how to sum elements in an array that may be either integers or strings representing integers. It uses Mojoâ€™s Variant to accommodate mixed data types within the same array. Notably, the data type of variable v3, whether String or Int, is determined only at runtime in this demo (dynamic type). from random import seed,random_ui64 from utils.variant import Variant alias IntOrString = Variant[Int, String] fn sum(*elements:IntOrString) -\u003e Int: var res:Int = 0 for i in range(len(elements)): if elements[i].isa[String](): try: res += int(elements[i].get[String]()[]) except e: print(\"Error:\", e,elements[i].get[String]()[]) else: res += elements[i].get[Int]()[] return res fn main(): seed() var v1 = IntOrString(4) var v2 = IntOrString(String(\"12\")) var v3:IntOrString if random_ui64(0, 1): print(\"v3 = String(21)\") v3 = String(\"21\") else: print(\"v3 = 21\") v3 = 21 print(\"result:\",sum(v1,v2,v3)) Output: v3 = String(21) result: 37 Mojo Playground: https://gist.github.com/modularbot/35306258030868a6113794349302b757 ","date":"2024-04-07","objectID":"/dynamic_types_via_variants/:0:0","tags":["mojo 24.2.0","utils","variant"],"title":"Dynamic types via Variants","uri":"/dynamic_types_via_variants/"},{"categories":["stdlib"],"content":" Context Mojo Documentation: SIMD select method Mojo Version: 24.2.0 Demo: Vectorized Relu Function This demo illustrates a practical application of conditional SIMD operations to implement the Relu activation function in a vectorized manner. The Relu function is defined as returning 0 for all input values less than 0 and the input value itself for those greater than 0. from algorithm import vectorize alias LEN = 7 alias dtype = DType.float32 alias simd_width = simdwidthof[dtype]() fn relu(input: DTypePointer[dtype], inout output: DTypePointer[dtype]): @parameter fn _cond_op[width: Int](i: Int): var mask = input.load[width=width](i) \u003e 0 output.store[width=width](i, mask.select( input.load[width=width](i),0)) vectorize[_cond_op, simd_width, size=LEN]() fn main(): var input = DTypePointer[dtype].alloc(LEN) var output = DTypePointer[dtype].alloc(LEN) for i in range(LEN): input[i] = -LEN // 2 + i + 1 relu(input,output) for i in range(LEN): print(\"relu(\",input[i],\") = \", output[i],sep=\"\") Output: relu(-3.0) = 0.0 relu(-2.0) = 0.0 relu(-1.0) = 0.0 relu(0.0) = 0.0 relu(1.0) = 1.0 relu(2.0) = 2.0 relu(3.0) = 3.0 Mojo Playground: https://gist.github.com/modularbot/d5ad733c1549ea75d80181df4474ad9c Remarks Special thanks to @sora from the Discord community for elucidating this technique. ","date":"2024-04-07","objectID":"/simd_select_method/:0:0","tags":["mojo 24.2.0","builtin","simd"],"title":"Conditional SIMD Operations","uri":"/simd_select_method/"},{"categories":null,"content":"Exploring the Mojo programming language through concise code examples. If you want to learn about this new kid on the block, head over to the excellent Mojo documentation. ","date":"2024-04-07","objectID":"/about/:0:0","tags":null,"title":"About","uri":"/about/"}]